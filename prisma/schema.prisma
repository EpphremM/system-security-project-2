// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client"
  output          = "../src/generated/prisma"
  // Enable preview features for better performance
  previewFeatures = ["postgresqlExtensions", "fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
}

// ============================================================================
// USER AND AUTHENTICATION MODELS
// ============================================================================

model User {
  id                String        @id @default(uuid())
  email             String        @unique
  emailVerified     DateTime?
  name              String?
  department        String
  roleId            String? // Link to Role model for RBAC
  role              Role?         @relation(fields: [roleId], references: [id])
  securityClearance SecurityLevel @default(INTERNAL)

  // Enhanced security fields
  passwordHash    String? // Nullable for passwordless auth
  mfaSecret       String?
  mfaEnabled      Boolean          @default(false)
  webauthnDevices WebAuthnDevice[]

  // Password security
  passwordHistory     PasswordHistory[]
  failedLoginAttempts Int               @default(0)
  accountLockedUntil  DateTime?
  lastFailedLoginAt   DateTime?

  // Next.js 16 specific
  preferredAuthMethod AuthMethod @default(PASSWORD)
  sessionVersion      Int        @default(1) // For session invalidation

  // MAC: Mandatory Access Control - Clearance
  clearance        UserClearance?
  clearanceHistory ClearanceHistory[]
  trustedSubject   Boolean            @default(false) // Admin exception to Bell-LaPadula

  // Timestamps with timezone
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  lastLoginAt       DateTime?
  passwordChangedAt DateTime?
  passwordExpiresAt DateTime? // Password maximum age: 90 days

  // Legacy fields (for backward compatibility)
  image            String?
  twoFactorEnabled Boolean @default(false) @map("two_factor_enabled")
  twoFactorSecret  String? @map("two_factor_secret")

  // Legacy role field (for backward compatibility)
  legacyRole UserRole? @default(USER)

  // Relations
  visitors              Visitor[]
  approvedVisitors      Visitor[]                @relation("approvedBy")
  accessPolicies        AccessPolicy[]           @relation("PolicyOwner")
  permissions           UserPermission[]
  auditLogs             AuditLog[]
  sessions              Session[]
  accounts              Account[]
  accessLogs            AccessLog[]
  visitorLogs           VisitorLog[]
  ownedResources        Resource[]               @relation("ResourceOwner") // DAC: Discretionary Access Control
  createdBackups        BackupLog[]              @relation("BackupCreator")
  updatedConfigs        SystemConfig[]           @relation("ConfigUpdater")
  mfaBackupCodes        MFABackupCode[]
  mfaEmergencyTokens    MFAEmergencyToken[]
  mfaEmailOTPs          MFAEmailOTP[]
  clearanceCompartments ClearanceCompartment[]   @relation("ClearanceUser")
  resourcePermissions   ResourcePermission[]
  sharingLinks          SharingLink[]
  roleAssignments       RoleAssignment[]
  roleRequests          RoleRequest[]            @relation("RoleRequestUser")
  roleRequestApprovals  RoleRequest[]            @relation("RoleRequestApprover")
  roleReviews           RoleReview[]
  deviceProfiles        DeviceProfile[]
  userAttributes        UserAttribute[]
  approvalRequests      VisitorApprovalRequest[] @relation("ApprovalHost")

  // Indexes for performance
  @@index([email])
  @@index([department, legacyRole])
  @@index([roleId])
  @@index([securityClearance])
  @@index([preferredAuthMethod])
  @@index([lastLoginAt])
  @@index([sessionVersion])
  @@map("users")
}

model WebAuthnDevice {
  id           String   @id @default(uuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  credentialId String   @unique
  publicKey    String   @db.Text
  counter      Int      @default(0)
  transports   String[] // WebAuthn transport types
  deviceName   String?

  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?

  @@index([userId])
  @@index([credentialId])
  @@map("webauthn_devices")
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

// ============================================================================
// SESSION MANAGEMENT (Enhanced Security)
// ============================================================================

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Enhanced session tracking and security
  ipAddress         String?
  userAgent         String?
  deviceFingerprint String? // Device identification
  location          String? // Geographic location
  isActive          Boolean   @default(true)
  revokedAt         DateTime? // For manual revocation
  revokedReason     String? // Reason for revocation

  // Session security attributes
  requiresMFA    Boolean  @default(false)
  mfaVerified    Boolean  @default(false)
  lastActivityAt DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([expires])
  @@index([sessionToken])
  @@index([isActive])
  @@index([revokedAt])
  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@index([expires])
  @@map("verification_tokens")
}

// ============================================================================
// ROLE-BASED ACCESS CONTROL (RBAC)
// ============================================================================

model Role {
  id          String  @id @default(uuid())
  name        String  @unique
  description String? @db.Text
  level       Int     @default(0) // Hierarchical level (higher = more privileges)

  // Hierarchical role structure
  parentId String?
  parent   Role?   @relation("RoleHierarchy", fields: [parentId], references: [id])
  children Role[]  @relation("RoleHierarchy")

  // Role permissions
  permissions RolePermission[]

  // Access policies requiring this role
  accessPolicies AccessPolicy[] @relation("PolicyRole")

  // Users with this role
  users           User[]
  roleAssignments RoleAssignment[]

  // Role lifecycle
  roleRequests RoleRequest[]
  roleReviews  RoleReview[]

  // System flags
  isSystem Boolean @default(false) // System roles cannot be deleted
  enabled  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([parentId])
  @@index([level])
  @@index([enabled])
  @@map("roles")
}

// ============================================================================
// PERMISSION SYSTEM (ACL - Access Control List)
// ============================================================================

model Permission {
  id          String  @id @default(uuid())
  name        String  @unique
  resource    String // Resource type (e.g., "visitor", "area", "document")
  action      String // Action type (e.g., "read", "write", "delete", "execute")
  description String? @db.Text

  // Relations
  rolePermissions RolePermission[]
  userPermissions UserPermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([resource, action])
  @@index([resource])
  @@index([action])
  @@map("permissions")
}

model RolePermission {
  id           String     @id @default(uuid())
  roleId       String
  permissionId String
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  // Permission modifiers
  granted    Boolean @default(true) // true = grant, false = deny
  conditions Json? // Additional conditions for this permission

  createdAt DateTime @default(now())

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
  @@map("role_permissions")
}

model UserPermission {
  id           String     @id @default(uuid())
  userId       String
  permissionId String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  // Permission modifiers
  granted    Boolean   @default(true)
  conditions Json? // Additional conditions
  expiresAt  DateTime? // Temporary permissions

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, permissionId])
  @@index([userId])
  @@index([permissionId])
  @@index([expiresAt])
  @@map("user_permissions")
}

// ============================================================================
// ACCESS POLICY SYSTEM (MAC, DAC, RBAC, RuBAC, ABAC)
// ============================================================================

model AccessPolicy {
  id          String  @id @default(uuid())
  name        String
  description String? @db.Text

  // Policy type: MAC, DAC, RBAC, RuBAC, ABAC
  policyType PolicyType

  // Resource and action
  resource String // Resource type (e.g., "visitor", "area", "document")
  action   String // Action type (e.g., "read", "write", "delete")

  // MAC (Mandatory Access Control) - Security labels
  minSecurityLabel SecurityLevel? // Minimum security clearance required
  maxSecurityLabel SecurityLevel? // Maximum security clearance allowed

  // DAC (Discretionary Access Control) - Resource ownership
  ownerId String? // Resource owner (for DAC)
  owner   User?   @relation("PolicyOwner", fields: [ownerId], references: [id])

  // RBAC (Role-Based Access Control) - Role requirements
  requiredRoleId String?
  requiredRole   Role?   @relation("PolicyRole", fields: [requiredRoleId], references: [id])

  // RuBAC (Rule-Based Access Control) - Rule conditions
  rules  Json? // Rule conditions (e.g., time-based, location-based)
  ruleId String? // Associated AccessRule
  rule   AccessRule? @relation(fields: [ruleId], references: [id])

  // ABAC (Attribute-Based Access Control) - Attribute conditions
  attributes Json? // Attribute conditions (e.g., department, clearance level)

  // General conditions (for complex policies)
  conditions Json? // Additional conditional access rules

  // Policy metadata
  priority Int     @default(0) // Higher priority policies evaluated first
  enabled  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([policyType])
  @@index([resource, action])
  @@index([ownerId])
  @@index([requiredRoleId])
  @@index([ruleId])
  @@index([enabled, priority])
  @@map("access_policies")
}

// ============================================================================
// SECURITY LABEL SYSTEM (Data Classification)
// ============================================================================

model SecurityLabel {
  id          String  @id @default(uuid())
  name        String  @unique
  level       Int     @default(0) // Numeric level for comparison
  description String? @db.Text

  // Classification attributes
  classification SecurityLevel
  dataCategory   DataCategory

  // MAC: Compartments (department-based segregation)
  compartments String[] // Array of compartment names (e.g., ["FINANCIAL", "HR"])

  // Label hierarchy
  parentId String?
  parent   SecurityLabel?  @relation("LabelHierarchy", fields: [parentId], references: [id])
  children SecurityLabel[] @relation("LabelHierarchy")

  // Resources with this label
  resources Resource[]

  // System flags
  isSystem Boolean @default(false)
  enabled  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([parentId])
  @@index([level])
  @@index([classification])
  @@index([enabled])
  @@map("security_labels")
}

// ============================================================================
// RESOURCE MODEL (For DAC and Security Labeling)
// ============================================================================

model Resource {
  id         String @id @default(uuid())
  type       String // Resource type (e.g., "visitor", "document", "area")
  resourceId String // ID of the actual resource (e.g., visitor ID)

  // DAC: Discretionary Access Control
  ownerId String
  owner   User   @relation("ResourceOwner", fields: [ownerId], references: [id])

  // MAC: Mandatory Access Control - Security labeling
  securityLabelId String
  securityLabel   SecurityLabel @relation(fields: [securityLabelId], references: [id])

  // Folder hierarchy for permission inheritance
  parentId String? // Parent folder/resource
  parent   Resource?  @relation("ResourceHierarchy", fields: [parentId], references: [id])
  children Resource[] @relation("ResourceHierarchy")

  // Access control metadata
  permissions Json? // Stored permissions (for quick lookup)

  // DAC: Shared permissions
  sharedPermissions ResourcePermission[]

  // DAC: Ownership transfer
  ownershipTransfers OwnershipTransfer[]

  // DAC: Sharing links
  sharingLinks SharingLink[]

  // ABAC: Resource attributes
  resourceAttributes ResourceAttribute[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([type, resourceId])
  @@index([ownerId])
  @@index([securityLabelId])
  @@index([type, resourceId])
  @@index([parentId])
  @@map("resources")
}

// ============================================================================
// AUDIT LOGGING (Encrypted Activity Logging)
// ============================================================================

model AuditLog {
  id     String  @id @default(uuid())
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Log category and type
  category LogCategory @default(USER_ACTIVITY)
  logType  LogType // Specific log type within category

  // Action details
  action     String
  resource   String
  resourceId String?

  // Security classification
  securityLabel SecurityLevel @default(INTERNAL)

  // Encrypted sensitive data
  encryptedDetails String? @db.Text // Encrypted JSON details
  encryptionKeyId  String? // Reference to encryption key

  // Log integrity
  hashChain        String? // Hash chain for sequential verification
  previousHash     String? // Hash of previous log in chain
  digitalSignature String? // Digital signature for batch verification
  batchId          String? // Batch ID for grouped logs
  isTampered       Boolean @default(false) // Tamper detection flag

  // Audit metadata
  details   Json? // Non-sensitive details
  ipAddress String?
  userAgent String?
  location  String? // Geographic location

  // Before/after states for data modifications
  beforeState Json? // State before modification
  afterState  Json? // State after modification

  // Access control decision
  accessGranted Boolean? // true = granted, false = denied, null = not applicable
  policyId      String? // Policy that made the decision
  policyType    PolicyType? // Type of policy (MAC, DAC, RBAC, etc.)
  denialReason  String?     @db.Text // Reason for denial

  // Performance metrics (for system logs)
  duration           Int? // Duration in milliseconds
  performanceMetrics Json? // Additional performance data

  // Error tracking (for system logs)
  errorCode    String?
  errorMessage String? @db.Text
  stackTrace   String? @db.Text

  // Compliance and retention
  retentionUntil   DateTime? // When this log can be deleted
  complianceTags   String[] // Compliance tags (e.g., "GDPR", "HIPAA", "SOX")
  subjectRequestId String? // For GDPR subject access requests

  // Export tracking
  exportedAt   DateTime?
  exportedBy   String?
  exportFormat String? // CSV, JSON, PDF, etc.

  createdAt      DateTime   @default(now())
  hashChainEntry HashChain?
  sourceAlerts   Alert[]

  @@index([userId])
  @@index([category])
  @@index([logType])
  @@index([action])
  @@index([resource, resourceId])
  @@index([securityLabel])
  @@index([accessGranted])
  @@index([policyType])
  @@index([createdAt])
  @@index([retentionUntil])
  @@index([complianceTags])
  @@index([subjectRequestId])
  @@index([batchId])
  @@index([hashChain])
  @@index([isTampered])
  @@map("audit_logs")
}

enum LogCategory {
  SECURITY // Authentication, access control, policy violations, config changes
  USER_ACTIVITY // Data access, modifications, permission changes, role assignments
  SYSTEM // Application events, backups, performance, errors
  COMPLIANCE // Subject requests, retention enforcement, regulatory checks
}

enum LogType {
  // Security Logs
  AUTH_SUCCESS
  AUTH_FAILURE
  AUTH_LOCKOUT
  MFA_SUCCESS
  MFA_FAILURE
  ACCESS_GRANTED
  ACCESS_DENIED
  POLICY_VIOLATION
  SECURITY_CONFIG_CHANGE
  CLEARANCE_CHANGE
  PERMISSION_CHANGE

  // User Activity Logs
  DATA_ACCESS
  DATA_CREATE
  DATA_UPDATE
  DATA_DELETE
  DATA_EXPORT
  PERMISSION_GRANT
  PERMISSION_REVOKE
  ROLE_ASSIGNED
  ROLE_REVOKED
  OWNERSHIP_TRANSFER

  // System Logs
  APP_START
  APP_STOP
  APP_ERROR
  BACKUP_START
  BACKUP_COMPLETE
  BACKUP_FAILED
  BACKUP_VERIFIED
  PERFORMANCE_METRIC
  EXCEPTION
  CONFIG_CHANGE

  // Compliance Logs
  SUBJECT_ACCESS_REQUEST
  DATA_RETENTION_ENFORCED
  DATA_DELETED_RETENTION
  AUDIT_EXPORT
  COMPLIANCE_CHECK
  GDPR_REQUEST
  HIPAA_AUDIT
}

// ============================================================================
// BACKUP LOGGING (Backup Tracking and Verification)
// ============================================================================

model BackupLog {
  id String @id @default(uuid())

  // Backup identification
  backupType BackupType
  backupName String
  backupPath String? // Storage path/location

  // Storage locations
  storageLocation StorageLocation @default(PRIMARY)
  primaryPath     String? // Primary storage path
  secondaryPath   String? // Secondary (cloud) storage path
  tertiaryPath    String? // Tertiary (off-site) storage path
  airGappedPath   String? // Air-gapped storage path

  // Backup metadata
  size        BigInt? // Size in bytes
  recordCount Int? // Number of records backed up

  // Verification
  checksum           String? // SHA-256 checksum for verification
  verified           Boolean   @default(false)
  verifiedAt         DateTime?
  verificationMethod String? // Method used for verification

  // Consistency checks
  preBackupChecksPassed   Boolean @default(false)
  postBackupChecksPassed  Boolean @default(false)
  consistencyCheckResults Json? // Pre-backup consistency check results

  // Encryption
  encrypted           Boolean @default(true)
  encryptionKeyId     String? // Reference to encryption key
  encryptionAlgorithm String? @default("AES-256-GCM")

  // Status
  status       BackupStatus @default(IN_PROGRESS)
  errorMessage String?      @db.Text

  // Restoration testing
  restorationTested     Boolean   @default(false)
  restorationTestDate   DateTime?
  restorationTestResult String? // PASSED, FAILED
  restorationTestNotes  String?   @db.Text

  // Retention
  expiresAt     DateTime? // When backup can be deleted
  retentionDays Int? // Retention period in days

  // Schedule information
  scheduledBackupId String? // Reference to scheduled backup
  scheduleType      String? // WEEKLY, DAILY, HOURLY, REAL_TIME

  // Relations
  createdById    String?
  createdBy      User?                 @relation("BackupCreator", fields: [createdById], references: [id])
  recoveryPlanId String?
  recoveryPlan   DisasterRecoveryPlan? @relation(fields: [recoveryPlanId], references: [id])

  startedAt   DateTime  @default(now())
  completedAt DateTime?
  createdAt   DateTime  @default(now())

  @@index([backupType])
  @@index([status])
  @@index([storageLocation])
  @@index([createdById])
  @@index([startedAt])
  @@index([expiresAt])
  @@index([verified])
  @@index([restorationTested])
  @@map("backup_logs")
}

// ============================================================================
// SYSTEM CONFIGURATION (Encrypted Configuration Storage)
// ============================================================================

model SystemConfig {
  id    String @id @default(uuid())
  key   String @unique
  value String @db.Text // Encrypted value

  // Encryption metadata
  encrypted           Boolean @default(true)
  encryptionKeyId     String? // Reference to encryption key
  encryptionAlgorithm String? @default("AES-256-GCM")

  // Configuration metadata
  category    String? // Configuration category
  description String? @db.Text
  sensitive   Boolean @default(false) // Whether value contains sensitive data

  // Access control
  restricted Boolean @default(false) // Requires special permission to read

  // Versioning
  version       Int     @default(1)
  previousValue String? @db.Text // Previous encrypted value for rollback

  // Audit
  updatedById String?
  updatedBy   User?   @relation("ConfigUpdater", fields: [updatedById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([key])
  @@index([category])
  @@index([sensitive])
  @@index([restricted])
  @@map("system_configs")
}

// ============================================================================
// VISITOR MANAGEMENT MODELS
// ============================================================================

model Visitor {
  id        String  @id @default(uuid())
  // Personal info
  firstName String
  lastName  String
  email     String?
  phone     String
  company   String

  // Visit details
  purpose VisitPurpose
  hostId  String
  host    User         @relation(fields: [hostId], references: [id])

  // Security classification
  securityLabel SecurityLevel @default(PUBLIC)
  dataCategory  DataCategory  @default(GENERAL)

  // Visit timing
  scheduledDate  DateTime
  scheduledStart DateTime
  scheduledEnd   DateTime
  actualCheckIn  DateTime?
  actualCheckOut DateTime?

  // Status with state machine
  status       VisitStatus @default(PENDING)
  approvalDate DateTime?
  approvedById String?
  approvedBy   User?       @relation(fields: [approvedById], references: [id], name: "approvedBy")

  // Documents (encrypted storage reference)
  documentId          String? // Reference to encrypted storage
  idDocumentEncrypted String? @db.Text // Encrypted ID document data

  // QR Code and Badge
  qrCode          String? // QR code hash for check-in (unique after generation)
  qrCodeExpiresAt DateTime? // QR code expiration
  badgeNumber     String? // Badge number
  badgePrintedAt  DateTime? // When badge was printed
  badgeExpiresAt  DateTime? // Badge expiration time

  // Group visit
  isGroupVisit Boolean @default(false)
  groupId      String? // Group identifier for bulk operations
  groupSize    Int? // Number of visitors in group

  // Approval workflow
  approvalRequestedAt       DateTime? // When approval was requested
  approvalEscalatedAt       DateTime? // When escalated to department head
  escalationReason          String?   @db.Text
  requiresSecurityClearance Boolean   @default(false)
  securityClearanceChecked  Boolean   @default(false)

  // Check-in/Check-out
  checkedInBy    String? // User who checked in visitor
  checkedOutBy   String? // User who checked out visitor
  idVerifiedAt   DateTime? // When ID was verified at reception
  hostNotifiedAt DateTime? // When host was notified of arrival

  // Data retention
  retentionPeriodStart DateTime? // When retention period starts (after check-out)
  retentionPeriodDays  Int? // Retention period in days

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  accessLogs       AccessLog[]
  visitorLogs      VisitorLog[]
  approvalRequests VisitorApprovalRequest[]
  areaAccess       VisitorAreaAccess[]
  digitalAccess    VisitorDigitalAccess?

  // Optimized indexes for common queries
  @@index([hostId, status])
  @@index([scheduledDate])
  @@index([status, scheduledDate])
  @@index([securityLabel, createdAt])
  @@index([approvedById])
  @@index([qrCode])
  @@index([groupId])
  @@index([approvalRequestedAt])
  @@map("visitors")
}

// ============================================================================
// VISITOR APPROVAL WORKFLOW
// ============================================================================

model VisitorApprovalRequest {
  id        String  @id @default(uuid())
  visitorId String
  visitor   Visitor @relation(fields: [visitorId], references: [id], onDelete: Cascade)

  // Request details
  requestedAt DateTime @default(now())
  requestedBy String? // User who requested (if not visitor)

  // Approval workflow
  hostId String // Host who needs to approve
  host   User                  @relation("ApprovalHost", fields: [hostId], references: [id])
  status ApprovalRequestStatus @default(PENDING)

  // Escalation
  escalatedTo      String? // Department head if escalated
  escalatedAt      DateTime?
  escalationReason String?   @db.Text

  // Approval/Rejection
  approvedAt      DateTime?
  approvedBy      String?
  rejectedAt      DateTime?
  rejectedBy      String?
  rejectionReason String?   @db.Text

  // Security clearance
  requiresSecurityClearance Boolean @default(false)
  securityClearanceChecked  Boolean @default(false)
  securityClearanceResult   String? // APPROVED, DENIED, PENDING

  // Notifications
  hostNotifiedAt       DateTime?
  escalationNotifiedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([visitorId])
  @@index([hostId])
  @@index([status])
  @@index([requestedAt])
  @@index([escalatedTo])
  @@map("visitor_approval_requests")
}

enum ApprovalRequestStatus {
  PENDING
  APPROVED
  REJECTED
  ESCALATED
  EXPIRED
}

model VisitorLog {
  id          String        @id @default(uuid())
  visitorId   String
  userId      String? // User who performed the action
  action      VisitorAction
  description String?       @db.Text
  metadata    Json? // Additional data about the action
  createdAt   DateTime      @default(now())

  // Relations
  visitor Visitor @relation(fields: [visitorId], references: [id], onDelete: Cascade)
  user    User?   @relation(fields: [userId], references: [id])

  @@index([visitorId])
  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("visitor_logs")
}

model AccessLog {
  id        String       @id @default(uuid())
  visitorId String?
  userId    String?
  action    AccessAction
  location  String? // Which area/room was accessed
  ipAddress String?
  userAgent String?
  metadata  Json?
  createdAt DateTime     @default(now())

  // Relations
  visitor Visitor? @relation(fields: [visitorId], references: [id])
  user    User?    @relation(fields: [userId], references: [id])

  @@index([visitorId])
  @@index([userId])
  @@index([action])
  @@index([location])
  @@index([createdAt])
  @@map("access_logs")
}

enum UserRole {
  VISITOR
  USER
  STAFF
  RECEPTIONIST
  DEPT_HEAD
  HR
  SECURITY
  IT_ADMIN
  ADMIN
  SUPER_ADMIN
}

enum SecurityLevel {
  PUBLIC
  INTERNAL
  CONFIDENTIAL
  RESTRICTED
  TOP_SECRET
}

enum AuthMethod {
  PASSWORD
  WEBAUTHN
  OTP
  SSO
}

enum PolicyType {
  MAC // Mandatory Access Control
  DAC // Discretionary Access Control
  RBAC // Role-Based Access Control
  RuBAC // Rule-Based Access Control
  ABAC // Attribute-Based Access Control
  HYBRID // Combination of multiple types
}

enum VisitStatus {
  PENDING
  APPROVED
  REJECTED
  CHECKED_IN
  CHECKED_OUT
  CANCELLED
  EXPIRED
  NO_SHOW
}

enum VisitPurpose {
  MEETING
  INTERVIEW
  DELIVERY
  MAINTENANCE
  TOUR
  TRAINING
  CONSULTATION
  OTHER
}

enum DataCategory {
  GENERAL
  PERSONAL
  CONFIDENTIAL
  RESTRICTED
  CLASSIFIED
}

enum VisitorAction {
  CREATED
  UPDATED
  CHECKED_IN
  CHECKED_OUT
  CANCELLED
  APPROVED
  REJECTED
  REMINDER_SENT
}

enum AccessAction {
  ENTRY
  EXIT
  DENIED
  ESCORTED
}

enum BackupType {
  FULL
  INCREMENTAL
  DIFFERENTIAL
  TRANSACTION_LOG
  CONFIGURATION
  MANUAL
  SCHEDULED
}

enum StorageLocation {
  PRIMARY // On-premise encrypted storage
  SECONDARY // Cloud storage (encrypted)
  TERTIARY // Off-site physical media
  AIR_GAPPED // Air-gapped backup
}

enum BackupStatus {
  IN_PROGRESS
  COMPLETED
  FAILED
  VERIFIED
  EXPIRED
}

// ============================================================================
// PASSWORD SECURITY MODELS
// ============================================================================

model PasswordHistory {
  id           String   @id @default(uuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  passwordHash String // Hashed password
  createdAt    DateTime @default(now())

  @@index([userId])
  @@index([userId, createdAt])
  @@map("password_history")
}

model AccountLockout {
  id          String      @id @default(uuid())
  identifier  String // Email or IP address
  type        LockoutType
  attempts    Int         @default(1)
  lockedUntil DateTime
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@unique([identifier, type])
  @@index([lockedUntil])
  @@index([type])
  @@map("account_lockouts")
}

enum LockoutType {
  USER_ACCOUNT
  IP_ADDRESS
}

// ============================================================================
// MANDATORY ACCESS CONTROL (MAC) - BELL-LAPADULA MODEL
// ============================================================================

model UserClearance {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Clearance level
  level SecurityLevel

  // Need-to-know compartments
  compartments String[] // Departments/categories user has access to

  // Clearance metadata
  assignedAt   DateTime        @default(now())
  assignedBy   String? // User ID who assigned clearance
  expiresAt    DateTime? // Annual review date
  nextReviewAt DateTime // Next annual review date
  status       ClearanceStatus @default(ACTIVE)

  // Escalation
  escalationRequested   Boolean   @default(false)
  escalationReason      String?   @db.Text
  escalationRequestedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([level])
  @@index([status])
  @@index([nextReviewAt])
  @@map("user_clearances")
}

model ClearanceHistory {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Clearance change details
  previousLevel        SecurityLevel?
  newLevel             SecurityLevel
  previousCompartments String[]
  newCompartments      String[]

  // Change metadata
  changedBy  String? // User ID who made the change
  reason     String?             @db.Text
  changeType ClearanceChangeType

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
  @@map("clearance_history")
}

model ClearanceCompartment {
  id          String  @id @default(uuid())
  name        String  @unique
  description String? @db.Text

  // Compartment type
  type CompartmentType

  // Users with access to this compartment
  users User[] @relation("ClearanceUser")

  // System flags
  isSystem Boolean @default(false)
  enabled  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
  @@index([enabled])
  @@map("clearance_compartments")
}

enum ClearanceStatus {
  ACTIVE
  PENDING
  SUSPENDED
  REVOKED
  EXPIRED
}

enum ClearanceChangeType {
  ASSIGNED
  UPGRADED
  DOWNGRADED
  REVOKED
  COMPARTMENT_ADDED
  COMPARTMENT_REMOVED
  REVIEWED
  ESCALATED
}

enum CompartmentType {
  FINANCIAL
  PERSONNEL
  OPERATIONAL
  VISITOR
  IT
  LEGAL
  EXECUTIVE
  CUSTOM
}

// ============================================================================
// DISCRETIONARY ACCESS CONTROL (DAC) - PERMISSION SHARING
// ============================================================================

model ResourcePermission {
  id         String   @id @default(uuid())
  resourceId String
  resource   Resource @relation(fields: [resourceId], references: [id], onDelete: Cascade)

  // Permission recipient
  userId  String? // User who has permission
  user    User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  groupId String? // Group that has permission (future: Role/Group model)

  // Permission types
  canRead    Boolean @default(false)
  canWrite   Boolean @default(false)
  canExecute Boolean @default(false)
  canDelete  Boolean @default(false)
  canShare   Boolean @default(false) // Can share with others

  // Time-bound permissions
  expiresAt DateTime?

  // Permission metadata
  grantedBy String // User ID who granted permission
  grantedAt DateTime @default(now())
  reason    String?  @db.Text

  // Inherited from parent
  inherited     Boolean @default(false)
  inheritedFrom String? // Resource ID this was inherited from

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([resourceId])
  @@index([userId])
  @@index([groupId])
  @@index([expiresAt])
  @@map("resource_permissions")
}

model OwnershipTransfer {
  id         String   @id @default(uuid())
  resourceId String
  resource   Resource @relation(fields: [resourceId], references: [id], onDelete: Cascade)

  // Transfer details
  fromUserId  String // Current owner
  toUserId    String // New owner
  requestedBy String // User who requested transfer
  approvedBy  String? // User who approved transfer

  // Transfer status
  status          TransferStatus @default(PENDING)
  reason          String?        @db.Text
  rejectionReason String?        @db.Text

  // Timestamps
  requestedAt DateTime  @default(now())
  approvedAt  DateTime?
  completedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([resourceId])
  @@index([fromUserId])
  @@index([toUserId])
  @@index([status])
  @@map("ownership_transfers")
}

model SharingLink {
  id         String   @id @default(uuid())
  resourceId String
  resource   Resource @relation(fields: [resourceId], references: [id], onDelete: Cascade)

  // Link details
  token     String @unique // Unique token for the sharing link
  createdBy String // User who created the link
  creator   User   @relation(fields: [createdBy], references: [id])

  // Permission controls
  canRead    Boolean @default(true)
  canWrite   Boolean @default(false)
  canExecute Boolean @default(false)
  canDelete  Boolean @default(false)
  canShare   Boolean @default(false)

  // Access controls
  expiresAt DateTime?
  maxUses   Int? // Maximum number of uses (null = unlimited)
  useCount  Int       @default(0)

  // Security
  password    String? // Optional password protection (hashed)
  requireAuth Boolean @default(false) // Require user authentication

  // Restrictions
  allowedEmails  String[] // Restrict to specific emails (empty = anyone)
  allowedDomains String[] // Restrict to specific domains (empty = any)

  // Metadata
  name        String? // Custom name for the link
  description String? @db.Text

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  lastUsedAt DateTime?

  @@index([resourceId])
  @@index([token])
  @@index([createdBy])
  @@index([expiresAt])
  @@map("sharing_links")
}

enum TransferStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
  CANCELLED
}

// ============================================================================
// ROLE-BASED ACCESS CONTROL (RBAC) - ROLE LIFECYCLE
// ============================================================================

model RoleAssignment {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  roleId String
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)

  // Role reviews for this assignment
  reviews RoleReview[] @relation("RoleReviewAssignment")

  // Assignment details
  assignedBy String // User ID who assigned the role
  assignedAt DateTime @default(now())

  // Temporary assignment
  isTemporary Boolean   @default(false)
  expiresAt   DateTime?

  // Assignment status
  status AssignmentStatus @default(ACTIVE)

  // Review tracking
  lastReviewedAt DateTime?
  nextReviewAt   DateTime? // 6 months from assignment

  // Deprovisioning
  deprovisionedAt   DateTime?
  deprovisionReason String?   @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
  @@index([status])
  @@index([expiresAt])
  @@index([nextReviewAt])
  @@map("role_assignments")
}

model RoleRequest {
  id     String @id @default(uuid())
  userId String
  user   User   @relation("RoleRequestUser", fields: [userId], references: [id], onDelete: Cascade)
  roleId String
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)

  // Request details
  requestedBy   String // User ID who requested (usually same as userId)
  requestedAt   DateTime @default(now())
  reason        String?  @db.Text
  justification String?  @db.Text

  // Approval workflow
  status          RequestStatus @default(PENDING)
  approvedBy      String?
  approver        User?         @relation("RoleRequestApprover", fields: [approvedBy], references: [id])
  approvedAt      DateTime?
  rejectionReason String?       @db.Text

  // Temporary request
  isTemporary        Boolean   @default(false)
  requestedExpiresAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([roleId])
  @@index([status])
  @@index([requestedAt])
  @@map("role_requests")
}

model RoleReview {
  id           String          @id @default(uuid())
  roleId       String
  role         Role            @relation(fields: [roleId], references: [id], onDelete: Cascade)
  assignmentId String? // Optional: specific assignment being reviewed
  assignment   RoleAssignment? @relation("RoleReviewAssignment", fields: [assignmentId], references: [id], onDelete: Cascade)

  // Review details
  reviewedBy String // User ID who conducted review
  reviewer   User       @relation(fields: [reviewedBy], references: [id])
  reviewedAt DateTime   @default(now())
  reviewType ReviewType

  // Review results
  approved        Boolean
  notes           String? @db.Text
  recommendations String? @db.Text

  // Next review
  nextReviewAt DateTime // 6 months from review

  createdAt DateTime @default(now())

  @@index([roleId])
  @@index([assignmentId])
  @@index([reviewedAt])
  @@index([nextReviewAt])
  @@map("role_reviews")
}

enum AssignmentStatus {
  ACTIVE
  PENDING
  SUSPENDED
  REVOKED
  EXPIRED
  DEPROVISIONED
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum ReviewType {
  ANNUAL
  AD_HOC
  DEPROVISIONING
  ESCALATION
}

// ============================================================================
// RULE-BASED ACCESS CONTROL (RuBAC) - RULE DEFINITIONS
// ============================================================================

model AccessRule {
  id          String  @id @default(uuid())
  name        String
  description String? @db.Text

  // Rule type
  ruleType RuleType

  // Rule configuration (JSON)
  config Json // Rule-specific configuration

  // Rule status
  enabled  Boolean @default(true)
  priority Int     @default(0) // Higher priority evaluated first

  // Emergency override
  emergencyOverride Boolean @default(false) // Can override other rules in emergency

  // Time-limited rule
  validFrom  DateTime?
  validUntil DateTime?

  // Associated policies
  policies AccessPolicy[]

  // Holiday schedule associations (for time-based rules)
  holidayScheduleId String?
  holidaySchedule   HolidaySchedule? @relation(fields: [holidayScheduleId], references: [id])

  // IP whitelist associations (for location-based rules)
  ipWhitelistId String?
  ipWhitelist   IPWhitelist? @relation(fields: [ipWhitelistId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ruleType])
  @@index([enabled])
  @@index([priority])
  @@index([validFrom, validUntil])
  @@index([holidayScheduleId])
  @@index([ipWhitelistId])
  @@map("access_rules")
}

model HolidaySchedule {
  id          String  @id @default(uuid())
  name        String
  description String? @db.Text

  // Holiday dates
  startDate DateTime
  endDate   DateTime

  // Holiday type
  type HolidayType

  // Recurring holidays
  isRecurring       Boolean @default(false)
  recurrencePattern Json? // For recurring holidays (e.g., every year)

  // Rule associations
  rules AccessRule[] @relation

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([startDate, endDate])
  @@index([type])
  @@map("holiday_schedules")
}

model IPWhitelist {
  id          String  @id @default(uuid())
  name        String
  description String? @db.Text

  // IP ranges (CIDR notation)
  ipRanges String[] // e.g., ["192.168.1.0/24", "10.0.0.0/8"]

  // Location metadata
  location String? // e.g., "Office Building A", "VPN Network"

  // Rule associations
  rules AccessRule[] @relation

  enabled Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([enabled])
  @@map("ip_whitelists")
}

model DeviceProfile {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Device identification
  deviceId   String     @unique // Unique device identifier
  deviceName String?
  deviceType DeviceType

  // Device attributes
  os             String? // Operating system
  osVersion      String?
  browser        String?
  browserVersion String?

  // Security attributes
  isCompanyManaged    Boolean @default(false)
  hasAntiMalware      Boolean @default(false)
  hasEncryptedStorage Boolean @default(false)

  // Device metadata
  lastSeen  DateTime @default(now())
  ipAddress String?
  userAgent String?

  // Trust level
  trustLevel TrustLevel @default(UNKNOWN)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([deviceId])
  @@index([trustLevel])
  @@index([isCompanyManaged])
  @@map("device_profiles")
}

enum RuleType {
  TIME_BASED
  LOCATION_BASED
  DEVICE_BASED
  COMPOSITE // Multiple rule types combined
}

enum HolidayType {
  PUBLIC_HOLIDAY
  COMPANY_HOLIDAY
  EMERGENCY_CLOSURE
  MAINTENANCE_WINDOW
}

enum DeviceType {
  DESKTOP
  LAPTOP
  MOBILE
  TABLET
  SERVER
  IOT
  UNKNOWN
}

enum TrustLevel {
  TRUSTED
  VERIFIED
  UNKNOWN
  UNTRUSTED
  BLOCKED
}

// ============================================================================
// ATTRIBUTE-BASED ACCESS CONTROL (ABAC)
// ============================================================================

model AttributeDefinition {
  id          String  @id @default(uuid())
  name        String  @unique
  description String? @db.Text

  // Attribute type
  attributeType AttributeType
  category      AttributeCategory

  // Value constraints
  valueType     ValueType
  allowedValues String[] // For ENUM type
  defaultValue  String? // Default value if not set

  // Validation
  minValue String? // For numeric/date types
  maxValue String? // For numeric/date types
  pattern  String? // Regex pattern for validation

  // Metadata
  isSystem Boolean @default(false)
  enabled  Boolean @default(true)

  // Attribute values
  userAttributes     UserAttribute[]
  resourceAttributes ResourceAttribute[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([attributeType])
  @@index([category])
  @@index([enabled])
  @@map("attribute_definitions")
}

model UserAttribute {
  id          String              @id @default(uuid())
  userId      String
  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  attributeId String
  attribute   AttributeDefinition @relation(fields: [attributeId], references: [id], onDelete: Cascade)

  // Attribute value
  value String @db.Text

  // Value metadata
  source     String? // Source of the attribute (e.g., "HR_SYSTEM", "MANUAL")
  verified   Boolean   @default(false)
  verifiedBy String? // User who verified
  verifiedAt DateTime?

  // Expiration
  expiresAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, attributeId])
  @@index([userId])
  @@index([attributeId])
  @@index([expiresAt])
  @@map("user_attributes")
}

model ResourceAttribute {
  id          String              @id @default(uuid())
  resourceId  String
  resource    Resource            @relation(fields: [resourceId], references: [id], onDelete: Cascade)
  attributeId String
  attribute   AttributeDefinition @relation(fields: [attributeId], references: [id], onDelete: Cascade)

  // Attribute value
  value String @db.Text

  // Value metadata
  source     String? // Source of the attribute
  calculated Boolean @default(false) // Auto-calculated vs manual

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([resourceId, attributeId])
  @@index([resourceId])
  @@index([attributeId])
  @@map("resource_attributes")
}

enum AttributeType {
  USER
  RESOURCE
  ENVIRONMENT
  COMPOSITE
}

enum AttributeCategory {
  IDENTITY // Role, department, clearance
  EMPLOYMENT // Status, contract type, training
  SECURITY // Certification, clearance level
  CLASSIFICATION // Resource classification
  METADATA // Creation date, sensitivity
  ENVIRONMENT // Time, network, threat level
  SYSTEM // Maintenance status, system state
}

enum ValueType {
  STRING
  NUMBER
  BOOLEAN
  DATE
  DATETIME
  ENUM
  JSON
}

// ============================================================================
// MULTI-FACTOR AUTHENTICATION (MFA) MODELS
// ============================================================================

model MFABackupCode {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  code      String // Hashed backup code
  used      Boolean   @default(false)
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([userId])
  @@index([userId, used])
  @@map("mfa_backup_codes")
}

model MFAEmergencyToken {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String    @unique // Hashed emergency token
  used      Boolean   @default(false)
  usedAt    DateTime?
  expiresAt DateTime
  createdAt DateTime  @default(now())

  @@index([userId])
  @@index([userId, used])
  @@index([expiresAt])
  @@map("mfa_emergency_tokens")
}

model MFAEmailOTP {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  code      String // Hashed OTP code
  used      Boolean   @default(false)
  usedAt    DateTime?
  expiresAt DateTime
  sentAt    DateTime  @default(now())
  ipAddress String? // IP address that requested the OTP
  createdAt DateTime  @default(now())

  @@index([userId])
  @@index([userId, used, expiresAt])
  @@index([expiresAt])
  @@map("mfa_email_otps")
}

// ============================================================================
// LOG SECURITY & MANAGEMENT
// ============================================================================

model EncryptionKey {
  id          String      @id @default(uuid())
  keyId       String      @unique // Unique key identifier
  category    LogCategory // Key per log category
  keyMaterial String      @db.Text // Encrypted key material (encrypted with master key)
  algorithm   String      @default("AES-256-GCM")
  keySize     Int         @default(256) // Key size in bits
  createdAt   DateTime    @default(now())
  expiresAt   DateTime // Key expiration (90 days from creation)
  rotatedAt   DateTime? // When key was rotated
  isActive    Boolean     @default(true)
  hsmKeyId    String? // HSM key identifier (if using HSM)

  // Key usage tracking
  usageCount Int       @default(0)
  lastUsedAt DateTime?

  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([isActive])
  @@index([expiresAt])
  @@index([keyId])
  @@map("encryption_keys")
}

model HashChain {
  id             String      @id @default(uuid())
  chainId        String      @unique // Unique chain identifier
  category       LogCategory // Chain per category
  previousHash   String? // Hash of previous entry in chain
  currentHash    String // Current hash
  logId          String      @unique // Reference to audit log
  log            AuditLog    @relation(fields: [logId], references: [id], onDelete: Cascade)
  sequenceNumber Int // Sequential number in chain
  createdAt      DateTime    @default(now())

  @@index([chainId])
  @@index([category])
  @@index([logId])
  @@index([sequenceNumber])
  @@map("hash_chains")
}

model LogBatch {
  id                 String      @id @default(uuid())
  batchId            String      @unique
  category           LogCategory
  logIds             String[] // Array of log IDs in batch
  signature          String      @db.Text // Digital signature of batch
  signatureAlgorithm String      @default("RSA-SHA256")
  signedBy           String? // User who signed
  signedAt           DateTime    @default(now())
  verified           Boolean     @default(false)
  verifiedAt         DateTime?
  createdAt          DateTime    @default(now())

  @@index([batchId])
  @@index([category])
  @@index([signedAt])
  @@map("log_batches")
}

model LogAnomaly {
  id          String    @id @default(uuid())
  anomalyType String // Type of anomaly detected
  severity    String // LOW, MEDIUM, HIGH, CRITICAL
  logId       String? // Related log ID
  description String    @db.Text
  detectedAt  DateTime  @default(now())
  resolved    Boolean   @default(false)
  resolvedAt  DateTime?
  resolvedBy  String?
  metadata    Json? // Additional anomaly data

  @@index([anomalyType])
  @@index([severity])
  @@index([detectedAt])
  @@index([resolved])
  @@map("log_anomalies")
}

model SIEMIntegration {
  id           String    @id @default(uuid())
  name         String    @unique
  type         String // SPLUNK, ELK, QRADAR, CUSTOM
  endpoint     String // SIEM endpoint URL
  apiKey       String?   @db.Text // Encrypted API key
  enabled      Boolean   @default(true)
  lastSyncAt   DateTime?
  syncInterval Int       @default(3600) // Sync interval in seconds
  filters      Json? // Log filters for this SIEM
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([enabled])
  @@index([type])
  @@map("siem_integrations")
}

model ScheduledReport {
  id         String          @id @default(uuid())
  reportType ReportType
  frequency  ReportFrequency
  recipients String[] // Email addresses

  // Report configuration
  filters Json? // Report filters
  format  String @default("PDF") // PDF, CSV, JSON

  // Schedule
  nextRunAt DateTime
  lastRunAt DateTime?
  enabled   Boolean   @default(true)

  // Report data
  lastReportData Json? // Last generated report data

  executions ReportExecution[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([reportType])
  @@index([frequency])
  @@index([enabled])
  @@index([nextRunAt])
  @@map("scheduled_reports")
}

// ============================================================================
// ALERTING & MONITORING
// ============================================================================

model Alert {
  id        String        @id @default(uuid())
  alertType AlertType
  severity  AlertSeverity
  title     String
  message   String        @db.Text
  category  AlertCategory

  // Alert source
  sourceType String? // LOG, ANOMALY, SYSTEM, MANUAL
  sourceId   String? // ID of source (log ID, anomaly ID, etc.)

  // Recipients
  recipients String[] // Email addresses or phone numbers
  channels   AlertChannel[] // EMAIL, SMS, DASHBOARD

  // Status
  status         AlertStatus @default(PENDING)
  acknowledged   Boolean     @default(false)
  acknowledgedBy String?
  acknowledgedAt DateTime?

  // Resolution
  resolved        Boolean   @default(false)
  resolvedBy      String?
  resolvedAt      DateTime?
  resolutionNotes String?   @db.Text

  // Metadata
  metadata    Json? // Additional alert data
  sourceLogId String? // Reference to audit log
  sourceLog   AuditLog? @relation(fields: [sourceLogId], references: [id])
  createdAt   DateTime  @default(now())
  sentAt      DateTime?

  @@index([alertType])
  @@index([severity])
  @@index([category])
  @@index([status])
  @@index([acknowledged])
  @@index([resolved])
  @@index([createdAt])
  @@map("alerts")
}

model DashboardAlert {
  id        String        @id @default(uuid())
  alertType String // UNUSUAL_ACCESS, POLICY_VIOLATION, PERFORMANCE, COMPLIANCE
  severity  AlertSeverity
  title     String
  message   String        @db.Text
  category  AlertCategory

  // Alert data
  data Json? // Chart data, metrics, etc.

  // Status
  active      Boolean   @default(true)
  dismissed   Boolean   @default(false)
  dismissedBy String?
  dismissedAt DateTime?

  // Time range
  startDate DateTime
  endDate   DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([alertType])
  @@index([severity])
  @@index([active])
  @@index([dismissed])
  @@index([startDate, endDate])
  @@map("dashboard_alerts")
}

model ReportExecution {
  id       String          @id @default(uuid())
  reportId String
  report   ScheduledReport @relation(fields: [reportId], references: [id], onDelete: Cascade)

  status      ReportStatus @default(RUNNING)
  startedAt   DateTime     @default(now())
  completedAt DateTime?

  // Report output
  reportData Json?
  reportUrl  String? // URL to generated report file

  errorMessage String? @db.Text

  createdAt DateTime @default(now())

  @@index([reportId])
  @@index([status])
  @@index([startedAt])
  @@map("report_executions")
}

enum AlertType {
  // Immediate Alerts
  MULTIPLE_FAILED_LOGINS
  UNAUTHORIZED_ACCESS
  CRITICAL_SYSTEM_ERROR
  BACKUP_FAILURE

  // Dashboard Alerts
  UNUSUAL_ACCESS_PATTERN
  POLICY_VIOLATION_TREND
  PERFORMANCE_DEGRADATION
  COMPLIANCE_GAP

  // Custom
  CUSTOM
}

enum AlertSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum AlertCategory {
  SECURITY
  SYSTEM
  COMPLIANCE
  PERFORMANCE
  BACKUP
}

enum AlertChannel {
  EMAIL
  SMS
  DASHBOARD
  WEBHOOK
}

enum AlertStatus {
  PENDING
  SENT
  FAILED
  CANCELLED
}

enum ReportType {
  // Scheduled Reports
  DAILY_SECURITY_SUMMARY
  WEEKLY_COMPLIANCE
  MONTHLY_AUDIT_REVIEW
  QUARTERLY_RISK_ASSESSMENT
  CUSTOM

  // Compliance Reports
  ACCESS_CONTROL_REVIEW
  USER_PERMISSION
  DATA_ACCESS_AUDIT
  POLICY_COMPLIANCE

  // Security Reports
  THREAT_INTELLIGENCE
  VULNERABILITY_ASSESSMENT
  SECURITY_INCIDENT
  RISK_ASSESSMENT

  // Operational Reports
  VISITOR_STATISTICS
  SYSTEM_PERFORMANCE
  BACKUP_SUCCESS
  USER_ACTIVITY
}

enum ReportFrequency {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  CUSTOM
}

enum ReportStatus {
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

// ============================================================================
// DISASTER RECOVERY
// ============================================================================

model DisasterRecoveryPlan {
  id          String  @id @default(uuid())
  name        String
  description String? @db.Text

  // System classification
  systemType SystemType
  rto        Int // Recovery Time Objective in hours
  rpo        Int // Recovery Point Objective in hours

  // Recovery procedures
  procedures    Json // Step-by-step recovery procedures
  prerequisites Json? // Prerequisites for recovery

  // Backup dependencies
  backupIds String[] // Required backup IDs
  backups   BackupLog[] @relation // Relation to backups

  // Recovery team
  recoveryTeam Json? // Team members and roles
  contactList  Json? // Contact information

  // Vendor information
  vendorContacts Json? // Vendor contact information

  // Regulatory procedures
  regulatoryProcedures Json? // Regulatory notification procedures

  // Testing
  lastTested   DateTime?
  nextTestDate DateTime?
  testResults  Json? // Test results

  // Status
  enabled Boolean @default(true)

  executions RecoveryExecution[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([systemType])
  @@index([enabled])
  @@index([nextTestDate])
  @@map("disaster_recovery_plans")
}

model RecoveryExecution {
  id     String               @id @default(uuid())
  planId String
  plan   DisasterRecoveryPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  // Execution details
  initiatedBy String
  startedAt   DateTime  @default(now())
  completedAt DateTime?

  // Status
  status      RecoveryStatus @default(IN_PROGRESS)
  currentStep Int            @default(0)
  totalSteps  Int

  // Results
  success      Boolean?
  errorMessage String?  @db.Text
  executionLog Json? // Detailed execution log

  createdAt DateTime @default(now())

  @@index([planId])
  @@index([status])
  @@index([startedAt])
  @@map("recovery_executions")
}

enum SystemType {
  CRITICAL // RTO: 4 hours
  IMPORTANT // RTO: 24 hours
  NON_CRITICAL // RTO: 72 hours
}

enum RecoveryStatus {
  IN_PROGRESS
  COMPLETED
  FAILED
  CANCELLED
  PAUSED
}

// ============================================================================
// SECURITY DASHBOARD & MANAGEMENT
// ============================================================================

model SecurityIncident {
  id          String @id @default(uuid())
  title       String
  description String @db.Text

  // Incident classification
  severity IncidentSeverity
  category IncidentCategory
  status   IncidentStatus   @default(OPEN)

  // Incident details
  detectedAt DateTime @default(now())
  reportedBy String? // User who reported
  assignedTo String? // User assigned to handle

  // Response
  playbookId       String? // Reference to response playbook
  responseSteps    Json? // Response steps taken
  communicationLog Json? // Communication log

  // Resolution
  resolvedAt      DateTime?
  resolvedBy      String?
  resolutionNotes String?   @db.Text

  // Post-incident
  reviewedAt     DateTime?
  reviewedBy     String?
  reviewNotes    String?   @db.Text
  lessonsLearned String?   @db.Text

  // Related entities
  relatedLogIds String[] // Related audit log IDs
  relatedUserId String? // Related user if applicable

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([severity])
  @@index([category])
  @@index([status])
  @@index([detectedAt])
  @@index([assignedTo])
  @@map("security_incidents")
}

model IncidentPlaybook {
  id          String           @id @default(uuid())
  name        String           @unique
  description String?          @db.Text
  category    IncidentCategory

  // Playbook steps
  steps Json // Step-by-step response procedures

  // Communication templates
  templates Json? // Communication templates for this incident type

  // Status
  enabled Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([enabled])
  @@map("incident_playbooks")
}

model SystemHealth {
  id String @id @default(uuid())

  // Health metrics
  status         HealthStatus @default(HEALTHY)
  cpuUsage       Float? // CPU usage percentage
  memoryUsage    Float? // Memory usage percentage
  diskUsage      Float? // Disk usage percentage
  networkLatency Int? // Network latency in ms

  // Application health
  databaseStatus String? // Database connection status
  apiStatus      String? // API response status
  backupStatus   String? // Last backup status

  // Security health
  activeThreats  Int @default(0)
  failedLogins   Int @default(0)
  activeSessions Int @default(0)

  // Timestamp
  recordedAt DateTime @default(now())

  @@index([status])
  @@index([recordedAt])
  @@map("system_health")
}

model ThreatIntelligence {
  id String @id @default(uuid())

  // Threat details
  threatType  ThreatType
  severity    ThreatSeverity
  source      String? // Threat source (IP, domain, etc.)
  description String         @db.Text

  // Location
  ipAddress String?
  country   String?
  region    String?

  // Status
  status    ThreatStatus @default(ACTIVE)
  blocked   Boolean      @default(false)
  blockedAt DateTime?

  // Detection
  detectedAt DateTime @default(now())
  detectedBy String? // System or user who detected

  // Resolution
  resolvedAt DateTime?
  resolvedBy String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([threatType])
  @@index([severity])
  @@index([status])
  @@index([detectedAt])
  @@index([ipAddress])
  @@map("threat_intelligence")
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum IncidentCategory {
  SECURITY_BREACH
  DATA_LEAK
  UNAUTHORIZED_ACCESS
  MALWARE
  DDoS
  PHISHING
  INSIDER_THREAT
  POLICY_VIOLATION
  SYSTEM_COMPROMISE
  OTHER
}

enum IncidentStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
  FALSE_POSITIVE
}

enum HealthStatus {
  HEALTHY
  WARNING
  CRITICAL
  UNKNOWN
}

enum ThreatType {
  MALICIOUS_IP
  SUSPICIOUS_ACTIVITY
  BRUTE_FORCE
  SQL_INJECTION
  XSS_ATTACK
  DDoS
  MALWARE
  PHISHING
  UNAUTHORIZED_ACCESS
  DATA_EXFILTRATION
  OTHER
}

enum ThreatSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ThreatStatus {
  ACTIVE
  INVESTIGATING
  MITIGATED
  RESOLVED
  FALSE_POSITIVE
}

// ============================================================================
// REPORTING SYSTEM
// ============================================================================

model Report {
  id          String     @id @default(uuid())
  reportType  ReportType
  reportName  String
  description String?    @db.Text

  // Report data
  reportData Json // Generated report data
  filters    Json? // Filters used to generate report

  // Format and storage
  format   ReportFormat @default(JSON)
  fileUrl  String? // URL to generated report file
  fileSize BigInt? // File size in bytes

  // Generation details
  generatedBy String
  generatedAt DateTime  @default(now())
  startDate   DateTime? // Report period start
  endDate     DateTime? // Report period end

  // Status
  status       ReportGenerationStatus @default(GENERATING)
  errorMessage String?                @db.Text

  // Schedule (if scheduled)
  scheduleId String?
  schedule   ReportSchedule? @relation(fields: [scheduleId], references: [id])

  // Template (if used)
  templateId String?
  template   ReportTemplate? @relation(fields: [templateId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([reportType])
  @@index([status])
  @@index([generatedBy])
  @@index([generatedAt])
  @@index([scheduleId])
  @@map("reports")
}

model ReportTemplate {
  id          String     @id @default(uuid())
  name        String     @unique
  description String?    @db.Text
  reportType  ReportType

  // Template configuration
  templateConfig Json // Template structure, fields, formatting

  // Default filters
  defaultFilters Json?

  // Status
  enabled Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reports   Report[]
  schedules ReportSchedule[]

  @@index([reportType])
  @@index([enabled])
  @@map("report_templates")
}

model ReportSchedule {
  id          String  @id @default(uuid())
  name        String  @unique
  description String? @db.Text

  // Schedule configuration
  reportType ReportType
  templateId String?
  template   ReportTemplate?   @relation(fields: [templateId], references: [id])
  frequency  ScheduleFrequency
  dayOfWeek  Int? // 0-6 (Sunday-Saturday) for weekly
  dayOfMonth Int? // 1-31 for monthly
  time       String? // HH:MM format

  // Recipients
  recipients String[] // Email addresses

  // Status
  enabled   Boolean   @default(true)
  lastRunAt DateTime?
  nextRunAt DateTime?

  reports Report[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([reportType])
  @@index([enabled])
  @@index([nextRunAt])
  @@map("report_schedules")
}

enum ReportFormat {
  JSON
  CSV
  PDF
  EXCEL
  HTML
}

enum ReportGenerationStatus {
  GENERATING
  COMPLETED
  FAILED
  EXPIRED
}

enum ScheduleFrequency {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
  ON_DEMAND
}

// ============================================================================
// VISITOR ACCESS CONTROL
// ============================================================================

model Area {
  id                String         @id @default(uuid())
  name              String         @unique
  description       String?        @db.Text
  zone              String // Zone identifier (e.g., "LOBBY", "OFFICE", "LAB", "SERVER_ROOM")
  securityLevel     SecurityLevel  @default(INTERNAL)
  requiresEscort    Boolean        @default(false)
  requiresClearance Boolean        @default(false)
  minClearance      SecurityLevel? // Minimum clearance required

  // Access control
  enabled Boolean @default(true)

  // Relations
  visitorAccess VisitorAreaAccess[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([zone])
  @@index([securityLevel])
  @@index([enabled])
  @@map("areas")
}

model VisitorAreaAccess {
  id        String  @id @default(uuid())
  visitorId String
  visitor   Visitor @relation(fields: [visitorId], references: [id], onDelete: Cascade)
  areaId    String
  area      Area    @relation(fields: [areaId], references: [id], onDelete: Cascade)

  // Access details
  grantedAt     DateTime  @default(now())
  expiresAt     DateTime // Time-limited access
  revokedAt     DateTime?
  revokedBy     String?
  revokedReason String?   @db.Text

  // Escort
  requiresEscort Boolean @default(false)
  escortId       String? // User who must escort
  escorted       Boolean @default(false)

  // Status
  active Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([visitorId])
  @@index([areaId])
  @@index([expiresAt])
  @@index([active])
  @@map("visitor_area_access")
}

model VisitorDigitalAccess {
  id        String  @id @default(uuid())
  visitorId String  @unique
  visitor   Visitor @relation(fields: [visitorId], references: [id], onDelete: Cascade)

  // WiFi credentials
  wifiUsername  String?   @unique
  wifiPassword  String?   @db.Text // Encrypted
  wifiSSID      String? // Network SSID
  wifiExpiresAt DateTime?

  // Network access
  networkAccessEnabled Boolean  @default(true)
  allowedIPs           String[] // Allowed IP addresses
  blockedIPs           String[] // Blocked IP addresses
  allowedPorts         Int[] // Allowed ports
  blockedPorts         Int[] // Blocked ports
  bandwidthLimit       Int? // Bandwidth limit in Mbps

  // Web portal
  webPortalEnabled Boolean @default(true)
  webPortalUrl     String?
  webPortalToken   String? @unique // Access token for portal

  // Printing
  printingEnabled Boolean @default(false)
  printQuota      Int? // Maximum pages
  printUsed       Int     @default(0)

  // Access control
  active    Boolean  @default(true)
  expiresAt DateTime // Digital access expiration

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([visitorId])
  @@index([wifiUsername])
  @@index([webPortalToken])
  @@index([expiresAt])
  @@index([active])
  @@map("visitor_digital_access")
}
